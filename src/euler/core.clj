(ns euler.core)

;; Multiples of 3 and 5 
;; Problem 1 
;; If we list all the natural numbers below 10
;; that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these
;; multiples is 23.

;; Find the sum of all the multiples of 3 or 5 below 1000.

;; First lets get a sequence of multiples of 3, 5, then both
(defn s1 []
  (let [m3 (range 0 1000 3)
        m5 (range 0 1000 5)
        mb (range 0 1000 15)]
    (+ (apply + m3) (apply + m5) (- (apply + mb)))))

(comment
  ;; more elegantly:
  (reduce + (filter #(or (= (mod % 3) 0) (= (mod % 5) 0)) (range 1 1000)))
  ;; or
  (apply + (set (concat (range 0 1000 3) (range 0 1000 5))))
  )

;; Even Fibonacci numbers
;; Problem 2

;; Each new term in the Fibonacci sequence is generated by adding the previous
;; two terms. By starting with 1 and 2, the first 10 terms will be:

;; 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

;; By considering the terms in the Fibonacci sequence whose values do not exceed
;; four million, find the sum of the even-valued terms.

;; First get Fibonacci numbers: Using a recursive definition may blow the stack,
;; I forgot what they said in SICP about this. I can use a loop, but I could
;; also use reduce. Clojure / java has some way of generating a
;; sequence. iterate should work.

(defn s2 []
  (let [fs (->> [1 2] (iterate (fn [[e1 e2]] [e2 (+ e1 e2)])) (map first) 
                (filter even?))]
    (apply + (take-while #(<= % 4000000) fs))))

;; Largest prime factor
;; Problem 3
;; The prime factors of 13195 are 5, 7, 13 and 29.

;; What is the largest prime factor of the number 600851475143 ?

;; Let's just create a factorization for the target by trying each number in the
;; range up to the target's square root, when a factor is found reset the target
;; to the result of dividing the factor and the target and reset the
;; factorization search for the new target; keep a list of all factors, these
;; factors will be prime; take the lagest

(defn s3 [target factors candidate]
  (let [max-candidate (int (Math/sqrt target))]
    (if (> candidate max-candidate) 
      (max (apply max factors) target)
      (if (= (mod target candidate) 0)
        (recur (/ target candidate) (conj factors candidate) 2)
        (recur target factors (inc candidate))))))

;; (s3 600851475143 [] 2)







